"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bot = void 0;
const events_1 = require("events");
const form_data_1 = __importDefault(require("form-data"));
const fs = __importStar(require("fs"));
const https_proxy_agent_1 = require("https-proxy-agent");
const ws_1 = require("ws");
const axios_1 = __importDefault(require("axios"));
const sessionManager_1 = require("./sessionManager");
const event_1 = require("./event");
const message_1 = require("./message");
const sender_1 = require("./entries/sender");
const log4js_1 = require("log4js");
const http_1 = require("http");
const querystring = __importStar(require("querystring"));
const utils_1 = require("./utils");
class Bot extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.options = options;
        this.self_id = "";
        this.nickname = "";
        this.status = 0;
        this.logger = (0, log4js_1.getLogger)(`[Discord]`);
        this.logger.level = options.log_level || 'info';
        this.server = (0, http_1.createServer)(this.requestHandler.bind(this));
        this.wss = new ws_1.WebSocketServer({ server: this.server });
        this.wss.on('connection', (client) => {
            const handleMsg = this.handleWs.bind(this, client);
            client.on('message', handleMsg);
            client.on('close', () => {
                this.logger.info('ws client closed');
            });
        });
        this.options.ignore_self = this.options.ignore_self || true;
        const config = {
            proxy: false,
            baseURL: 'https://discord.com/api',
        };
        if (this.options.proxy) {
            config.httpsAgent = new https_proxy_agent_1.HttpsProxyAgent(`http://${this.options.proxy.host}:${this.options.proxy.port}`);
        }
        this.request = axios_1.default.create(config);
        this.sessionManager = new sessionManager_1.SessionManager(this);
        this.request.interceptors.request.use((config) => {
            config.headers.set('Authorization', `Bot ${this.sessionManager.token}`);
            config.headers.set('User-Agent', `DiscordBot (${config.url}, 10)`);
            return config;
        });
    }
    async requestHandler(req, res) {
        const { url } = req;
        if (url === '/')
            return res.writeHead(200).end('Discord Bot');
        const queryParam = querystring.parse(req.url);
        const { method, headers } = req;
        if (method === 'POST' && headers['content-type'] === 'application/x-www-form-urlencoded') {
            const body = querystring.parse(req['body']);
            if (this.options.access_token &&
                !body.access_token?.includes(this.options.access_token) &&
                !queryParam.access_token?.includes(this.options.access_token)) {
                return res.writeHead(401).end('Unauthorized');
            }
            const { action = queryParam.action, params = queryParam.params } = body;
            try {
                const result = await this.applyMethod(req, action, params);
                res.writeHead(200).end(result);
            }
            catch (e) {
                this.logger.error(e);
                res.writeHead(500).end(`Internal Server Error`);
            }
        }
        if (this.options.access_token && queryParam.access_token !== this.options.access_token)
            return res.writeHead(401).end('Unauthorized');
        return this.applyMethod(req, queryParam.action, queryParam.params);
    }
    async handleWs(client, message) {
        try {
            const payload = JSON.parse(message.toString());
            const { action, params, echo } = payload;
            if (action) {
                const result = await this.applyMethod(client, action, params);
                return client.send(JSON.stringify({
                    type: 'action_result',
                    echo,
                    data: {
                        action,
                        result,
                    },
                }));
            }
        }
        catch (e) {
            this.logger.error(e);
            client.send(JSON.stringify({
                type: 'server.error',
                data: e.message,
            }));
        }
    }
    sendWsMsg(event) {
        if (this.options.ignore_self && event.user_id === this.self_id)
            return;
        const msg = JSON.stringify({
            type: 'event',
            data: event,
        });
        for (const client of this.wss.clients) {
            client.send(msg);
        }
    }
    async applyMethod(source, action, params) {
        const fn = this[action];
        if (!fn || typeof fn !== 'function')
            return fn;
        return await fn(...(0, utils_1.getArgs)(fn, params));
    }
    dispatchEvent(event, wsRes) {
        const payload = wsRes.d;
        const event_id = wsRes.id || '';
        if (!payload || !event)
            return;
        const transformEvent = event_1.OriginEvent[event] || 'system';
        const eventPayload = this.processPayload(event_id, transformEvent, payload);
        if (eventPayload.user_id === this.self_id && this.options.ignore_self)
            return;
        this.em(transformEvent, eventPayload);
    }
    processPayload(event_id, event, payload) {
        let [post_type, ...sub_type] = event.split('.');
        const result = {
            event_id,
            post_type,
            [`${post_type}_type`]: sub_type.join('.'),
            ...payload
        };
        if (['message.group', 'message.private', 'message.guild', 'message.direct'].includes(event)) {
            const [message, brief] = message_1.Message.parse.call(this, payload);
            result.message = message;
            const member = payload.member;
            const permissions = member?.roles || [];
            Object.assign(result, {
                user_id: payload.author?.id,
                id: payload.event_id || payload.id,
                message_id: payload.event_id || payload.id,
                raw_message: brief,
                sender: {
                    user_id: payload.author?.id,
                    user_name: payload.author?.username,
                    permissions: ['normal'].concat(permissions),
                    user_openid: payload.author?.user_openid || payload.author?.member_openid
                },
                timestamp: new Date(payload.timestamp).getTime() / 1000,
            });
            let messageEvent;
            switch (event) {
                case 'message.guild':
                    messageEvent = new message_1.GuildMessageEvent(this, result);
                    this.sendWsMsg(messageEvent);
                    this.logger.info(`recv Guild(${result.guild_id})Channel(${result.channel_id}): ${result.raw_message}`);
                    break;
                case 'message.direct':
                    messageEvent = new message_1.DirectMessageEvent(this, result);
                    this.sendWsMsg(messageEvent);
                    this.logger.info(`recv Direct(${result.guild_id}): ${result.raw_message}`);
                    break;
            }
            return messageEvent;
        }
        return result;
    }
    em(event, payload) {
        const eventNames = event.split('.');
        const [post_type, detail_type, ...sub_type] = eventNames;
        Object.assign(payload, {
            post_type,
            [`${post_type}_type`]: detail_type,
            sub_type: sub_type.join('.'),
            ...payload
        });
        let prefix = '';
        while (eventNames.length) {
            let fullEventName = `${prefix}.${eventNames.shift()}`;
            if (fullEventName.startsWith('.'))
                fullEventName = fullEventName.slice(1);
            this.emit(fullEventName, payload);
            prefix = fullEventName;
        }
    }
    async getGuildList() {
        const _getGuildList = async (after = undefined) => {
            const res = await this.request.get('/users/@me/guilds', {
                params: {
                    after
                }
            }).catch(() => ({ data: [] })); // 私域不支持获取频道列表，做个兼容
            if (!res.data?.length)
                return [];
            const result = (res.data || []).map(g => {
                const { id: guild_id, name: guild_name, joined_at, ...guild } = g;
                return {
                    guild_id,
                    guild_name,
                    join_time: new Date(joined_at).getTime() / 1000,
                    ...guild
                };
            });
            const last = result[result.length - 1];
            return [...result, ...await _getGuildList(last.guild_id)];
        };
        return await _getGuildList();
    }
    async getGuildMemberList(guild_id) {
        const _getGuildMemberList = async (after = undefined) => {
            const res = await this.request.get(`/users/@me/guilds/${guild_id}/members`, {
                params: {
                    after,
                    limit: 100
                }
            }).catch(() => ({ data: [] })); // 公域没有权限，做个兼容
            if (!res.data?.length)
                return [];
            const result = (res.data || []).map(m => {
                const { id: member_id, name: member_name, role, join_time, ...member } = m;
                return {
                    member_id,
                    member_name,
                    role,
                    join_time: new Date(join_time).getTime() / 1000,
                    ...member
                };
            });
            const last = result[result.length - 1];
            return [...result, ...await _getGuildMemberList(last.member_id)];
        };
        return await _getGuildMemberList();
    }
    async uploadMedia(file) {
        const formData = new form_data_1.default();
        const [type] = file.split('.').reverse();
        const headers = formData.getHeaders();
        const fileData = fs.createReadStream(file);
        if (file.startsWith('http')) {
            const data = await this.request.get(file, {
                responseType: 'stream'
            });
            fileData.pipe(data.data);
        }
        formData.append('media', fileData);
        formData.append('type', type);
        return new Promise((resolve, reject) => {
            formData.getLength(async (e, l) => {
                if (e)
                    return reject(e);
                headers['content-length'] = l;
                const response = await this.request.post('https://oapi.dingtalk.com/media/upload', formData, {
                    headers: {
                        "Content-Type": 'multipart/form-data'
                    }
                });
                resolve({
                    ...response.data,
                    type
                });
            });
        });
    }
    async sendDirectMessage(guild_id, message, source) {
        const sender = new sender_1.Sender(this, `/dms/${guild_id}`, message, source);
        const result = await sender.sendMsg();
        this.logger.info(`send to Direct(${guild_id}): ${sender.brief}`);
        return result;
    }
    async sendGuildMessage(channel_id, message, source) {
        const sender = new sender_1.Sender(this, `/channels/${channel_id}`, message, source);
        const result = await sender.sendMsg();
        this.logger.info(`send to Channel(${channel_id}): ${sender.brief}`);
        return result;
    }
    async start() {
        var _a;
        await this.sessionManager.start();
        this.server.listen((_a = this.options).port || (_a.port = 3723), () => {
            this.logger.info('server started as port: ' + this.options.port);
        });
    }
    stop() {
        // this.sessionManager.stop()
    }
}
exports.Bot = Bot;
