"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionManager = void 0;
const events_1 = require("events");
const ws_1 = require("ws");
const constans_1 = require("./constans");
const utils_1 = require("./utils");
const https_proxy_agent_1 = require("https-proxy-agent");
class SessionManager extends events_1.EventEmitter {
    get token() {
        return this.bot.options.token;
    }
    constructor(bot) {
        super();
        this.bot = bot;
        this.wsUrl = `wss://gateway.discord.gg/?v=10&encoding=json`;
        this.retry = 0;
        this.sessionRecord = {
            sessionID: "",
            seq: 0
        };
        this.heartbeatParam = {
            op: constans_1.OpCode.HEARTBEAT,
            d: null // 心跳唯一值
        };
        this.on(constans_1.SessionEvents.EVENT_WS, (data) => {
            switch (data.eventType) {
                case constans_1.SessionEvents.RECONNECT:
                    this.bot.logger.debug("[CLIENT] 等待断线重连中...");
                    break;
                case constans_1.SessionEvents.DISCONNECT:
                    if (this.retry < (this.bot.options.max_reconnect_count || constans_1.MAX_RETRY)) {
                        this.bot.logger.debug("[CLIENT] 重新连接中，尝试次数：", this.retry + 1);
                        if (constans_1.WebsocketCloseReason.find((v) => v.code === data.code)?.resume) {
                            this.sessionRecord = data.eventMsg;
                        }
                        this.isReconnect = true;
                        this.start();
                        this.retry += 1;
                    }
                    else {
                        this.bot.logger.debug("[CLIENT] 超过重试次数，连接终止");
                        this.emit(constans_1.SessionEvents.DEAD, {
                            eventType: constans_1.SessionEvents.ERROR,
                            msg: "连接已死亡，请检查网络或重启"
                        });
                    }
                    break;
                case constans_1.SessionEvents.READY:
                    this.bot.logger.debug("[CLIENT] 连接成功");
                    this.retry = 0;
                    break;
                default:
            }
        });
        this.on(constans_1.SessionEvents.ERROR, (e) => {
            this.bot.logger.error(`[CLIENT] 发生错误：${e}`);
        });
    }
    async start() {
        this.connect();
        this.startListen();
    }
    connect() {
        const options = {
            headers: {
                "Authorization": "Bot " + this.token,
            }
        };
        if (this.bot.options.proxy) {
            options.agent = new https_proxy_agent_1.HttpsProxyAgent(`http://${this.bot.options.proxy.host}:${this.bot.options.proxy.port}`);
        }
        this.bot.ws = new ws_1.WebSocket(this.wsUrl, options);
    }
    reconnectWs() {
        const reconnectParam = {
            op: constans_1.OpCode.RESUME,
            d: {
                // token: `Bot ${this.bot.appId}${this.token}`,
                token: this.token,
                session_id: this.sessionRecord.sessionID,
                seq: this.sessionRecord.seq
            }
        };
        this.sendWs(reconnectParam);
    }
    // 发送websocket
    sendWs(msg) {
        try {
            // 先将消息转为字符串
            this.bot.ws.send(typeof msg === "string" ? msg : JSON.stringify(msg));
        }
        catch { }
    }
    authWs() {
        this.sendWs(this.heartbeatParam);
        this.sendWs({
            op: constans_1.OpCode.IDENTIFY,
            d: {
                token: this.token,
                intents: this.getValidIntends(), // todo 接受的类型
                properties: {
                    os: 'linux',
                    browser: 'ts-disc-bot',
                    device: 'ts-disc-bot'
                }
            }
        });
    }
    startListen() {
        this.bot.ws.on('open', () => {
            this.bot.logger.log('connect open');
        });
        this.bot.ws.on("close", (code) => {
            this.alive = false;
            this.bot.logger.error(`[CLIENT] 连接关闭：${code}`);
            this.emit(constans_1.SessionEvents.EVENT_WS, {
                eventType: constans_1.SessionEvents.DISCONNECT,
                code,
                eventMsg: this.sessionRecord
            });
            if (code) {
                constans_1.WebsocketCloseReason.forEach((e) => {
                    if (e.code === code) {
                        this.emit(constans_1.SessionEvents.ERROR, e.reason);
                    }
                });
            }
        });
        this.bot.ws.on("error", (e) => {
            this.alive = false;
            this.bot.logger.debug("[CLIENT] 连接错误");
            this.emit(constans_1.SessionEvents.CLOSED, { eventType: constans_1.SessionEvents.CLOSED });
        });
        this.bot.ws.on("message", (data) => {
            this.bot.logger.debug(`[CLIENT] 收到消息: ${data}`);
            // 先将消息解析
            const wsRes = (0, utils_1.toObject)(data);
            // 先判断websocket连接是否成功
            if (wsRes?.op === constans_1.OpCode.HELLO && wsRes?.d?.heartbeat_interval) {
                // websocket连接成功，拿到心跳周期
                this.heartbeatInterval = wsRes?.d?.heartbeat_interval;
                // 非断线重连时，需要鉴权
                this.isReconnect ? this.reconnectWs() : this.authWs();
                return;
            }
            // 鉴权通过
            if (wsRes.t === constans_1.SessionEvents.READY) {
                this.bot.logger.debug(`[CLIENT] 鉴权通过`);
                const { d, s } = wsRes;
                const { session_id, user = {} } = d;
                this.bot.self_id = user.id;
                this.bot.nickname = user.username;
                this.bot.status = user.status || 0;
                // 获取当前会话参数
                if (session_id && s) {
                    this.sessionRecord.sessionID = session_id;
                    this.sessionRecord.seq = s;
                    this.heartbeatParam.d = s;
                }
                this.bot.logger.info(`connect to ${user.username}(${user.id})`);
                this.isReconnect = false;
                this.emit(constans_1.SessionEvents.READY, { eventType: constans_1.SessionEvents.READY, msg: d || "" });
                // 第一次发送心跳
                this.bot.logger.debug(`[CLIENT] 发送第一次心跳`, this.heartbeatParam);
                this.sendWs(this.heartbeatParam);
                return;
            }
            // 心跳测试
            if (wsRes.op === constans_1.OpCode.HEARTBEAT_ACK || wsRes.t === constans_1.SessionEvents.RESUMED) {
                if (!this.alive) {
                    this.alive = true;
                    this.emit(constans_1.SessionEvents.EVENT_WS, { eventType: constans_1.SessionEvents.READY });
                }
                this.bot.logger.debug("[CLIENT] 心跳校验", this.heartbeatParam);
                setTimeout(() => {
                    this.sendWs(this.heartbeatParam);
                }, this.heartbeatInterval);
            }
            // 收到服务端重连的通知
            if (wsRes.op === constans_1.OpCode.RECONNECT) {
                // 通知会话，当前已断线
                this.emit(constans_1.SessionEvents.EVENT_WS, { eventType: constans_1.SessionEvents.RECONNECT });
            }
            // 服务端主动推送的消息
            if (wsRes.op === constans_1.OpCode.DISPATCH) {
                // 更新心跳唯一值
                const { s } = wsRes;
                if (s)
                    this.sessionRecord.seq = this.heartbeatParam.d = s;
                // OpenAPI事件分发
                this.bot.dispatchEvent(wsRes.t, wsRes);
            }
        });
    }
    getValidIntends() {
        if (typeof this.bot.options.intents === 'number')
            return this.bot.options.intents;
        return (this.bot.options.intents || []).reduce((result, item) => {
            const value = constans_1.Intends[item];
            if (value === undefined) {
                this.bot.logger.warn(`Invalid intends(${item}),skip...`);
                return result;
            }
            return constans_1.Intends[item] | result;
        }, 0);
    }
}
exports.SessionManager = SessionManager;
