"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parserMessage = void 0;
function parseFromText(text) {
    const result = [];
    const matchReg = /\[!]+]/;
    while (text.length) {
        const [match] = matchReg.exec(text) || [];
        if (!match)
            break;
        const matchIdx = text.indexOf(match);
        if (matchIdx > 0)
            result.push({ type: 'text', text: text.slice(0, matchIdx) });
        text = text.slice(matchIdx);
        result.push({
            type: 'face',
            id: match.slice(1, -1)
        });
    }
    if (text.length) {
        result.push({
            type: 'text',
            text
        });
    }
    return result;
}
async function parseFromRichText(list) {
    const result = [];
    for (const item of list) {
        switch (item.type) {
            case 'picture':
                const imageInfo = await this.downloadFile(item.downloadCode);
                result.push({
                    type: 'image',
                    file: imageInfo.downloadUrl
                });
                break;
            default:
                result.push(...parseFromText(item.text));
        }
    }
    return result;
}
async function parserMessage(bot, payload) {
    switch (payload.msgtype) {
        case 'text':
            return parseFromText(payload.text.content);
        case 'picture':
            const imageInfo = await bot.downloadFile(payload.content.downloadCode);
            return [{
                    type: 'image',
                    url: imageInfo.downloadUrl
                }];
        case 'richText':
            return await parseFromRichText.apply(bot, [payload.content.richText]);
        case 'file':
            const fileInfo = await bot.downloadFile(payload.content.downloadCode);
            return [{
                    type: 'file',
                    name: payload.content.fileName,
                    url: fileInfo.downloadUrl,
                }];
        default:
            return [];
    }
}
exports.parserMessage = parserMessage;
